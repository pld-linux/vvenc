From 83d5af3bdb440d453e4c7910c5341ca40ebabe9e Mon Sep 17 00:00:00 2001
From: Gabriel Hege <gabriel.hege@hhi.fraunhofer.de>
Date: Mon, 31 Mar 2025 11:29:43 +0200
Subject: [PATCH] fix mismatched #if/#endif

---
 source/Lib/vvenc/vvencimpl.cpp | 60 ++++++++++++++++------------------
 1 file changed, 29 insertions(+), 31 deletions(-)

diff --git a/source/Lib/vvenc/vvencimpl.cpp b/source/Lib/vvenc/vvencimpl.cpp
index 7f501f0a..cdea57de 100644
--- a/source/Lib/vvenc/vvencimpl.cpp
+++ b/source/Lib/vvenc/vvencimpl.cpp
@@ -800,25 +800,24 @@ void VVEncImpl::registerMsgCbf( void * ctx, vvencLoggingCallback msgFnc )
 const char* VVEncImpl::setSIMDExtension( const char* simdId )
 {
   const std::string simdReqStr( simdId ? simdId : "" );
-#if ENABLE_SIMD_OPT
-#if defined( TARGET_SIMD_X86 ) || defined( TARGET_SIMD_ARM )
-#if HANDLE_EXCEPTION
+#if ENABLE_SIMD_OPT && ( defined( TARGET_SIMD_X86 ) || defined( TARGET_SIMD_ARM ) )
+# if HANDLE_EXCEPTION
   try
-#endif  // HANDLE_EXCEPTION
+# endif  // HANDLE_EXCEPTION
   {
-#if defined( TARGET_SIMD_ARM )
+# if defined( TARGET_SIMD_ARM )
     ARM_VEXT arm_ext = string_to_arm_vext( simdReqStr );
-#if defined( TARGET_SIMD_X86 )
+#  if defined( TARGET_SIMD_X86 )
     // Translate any non-scalar Arm SIMD request to enable SIMDe.
     X86_VEXT x86_ext = arm_ext == arm_simd::UNDEFINED ? x86_simd::UNDEFINED
                      : arm_ext == arm_simd::SCALAR    ? x86_simd::SCALAR
                                                       : SIMD_EVERYWHERE_EXTENSION_LEVEL;
-#endif
+#  endif  // TARGET_SIMD_X86
     try
     {
-#if defined( TARGET_SIMD_X86 )
+#  if defined( TARGET_SIMD_X86 )
       read_x86_extension_flags( x86_ext );
-#endif
+#  endif   // TARGET_SIMD_X86
       read_arm_extension_flags( arm_ext );
     }
     catch( Exception& )
@@ -828,7 +827,7 @@ const char* VVEncImpl::setSIMDExtension( const char* simdId )
       THROW( "requested SIMD level (" << simdReqStr << ") not supported by current CPU (max "
                                       << read_arm_extension_name() << ")." );
     }
-#else  // defined( TARGET_SIMD_X86 )
+# else  // defined( TARGET_SIMD_X86 )
     X86_VEXT request_ext = string_to_x86_vext( simdReqStr );
     try
     {
@@ -841,42 +840,41 @@ const char* VVEncImpl::setSIMDExtension( const char* simdId )
       THROW( "requested SIMD level (" << simdReqStr << ") not supported by current CPU (max "
                                       << read_x86_extension_name() << ")." );
     }
-#endif
-#endif //ENABLE_SIMD_OPT
+# endif  // defined( TARGET_SIMD_X86 )
 
-#if ENABLE_SIMD_OPT_BUFFER
-#if defined( TARGET_SIMD_X86 )
+# if ENABLE_SIMD_OPT_BUFFER
+#  if defined( TARGET_SIMD_X86 )
     g_pelBufOP.initPelBufOpsX86();
-#endif
-#if defined( TARGET_SIMD_ARM )
+#  endif
+#  if defined( TARGET_SIMD_ARM )
     g_pelBufOP.initPelBufOpsARM();
-#endif
-#endif  // ENABLE_SIMD_OPT_BUFFER
+#  endif
+# endif   // ENABLE_SIMD_OPT_BUFFER
 
-#if ENABLE_SIMD_TRAFO
-#if defined( TARGET_SIMD_X86 )
+# if ENABLE_SIMD_TRAFO
+#  if defined( TARGET_SIMD_X86 )
     g_tCoeffOps.initTCoeffOpsX86();
-#endif
-#if defined( TARGET_SIMD_ARM )
+#  endif   // TARGET_SIMD_X86
+#  if defined( TARGET_SIMD_ARM )
     g_tCoeffOps.initTCoeffOpsARM();
-#endif
-#endif  // ENABLE_SIMD_TRAFO
+#  endif   // TARGET_SIMD_ARM
+# endif    // ENABLE_SIMD_TRAFO
 
-#if defined( TARGET_SIMD_ARM )
+# if defined( TARGET_SIMD_ARM )
     return read_arm_extension_name().c_str();
-#else
+# else    // !TARGET_SIMD_ARM
     return read_x86_extension_name().c_str();
-#endif
+# endif   // !TARGET_SIMD_ARM
   }
-#if HANDLE_EXCEPTION
+# if HANDLE_EXCEPTION
   catch( Exception& e )
   {
     MsgLog msg;
     msg.log( VVENC_ERROR, "\n%s\n", e.what() );
     return nullptr;
   }
-#endif  // HANDLE_EXCEPTION
-#else   // !defined( TARGET_SIMD_X86 ) && !defined( TARGET_SIMD_ARM )
+# endif  // HANDLE_EXCEPTION
+#else   // !( ENABLE_SIMD_OPT && ( defined( TARGET_SIMD_X86 ) || defined( TARGET_SIMD_ARM ) ) )
   if( !simdReqStr.empty() && simdReqStr != "SCALAR" )
   {
     MsgLog msg;
@@ -884,7 +882,7 @@ const char* VVEncImpl::setSIMDExtension( const char* simdId )
     return nullptr;
   }
   return "SCALAR";
-#endif  // defined( TARGET_SIMD_X86 ) || defined( TARGET_SIMD_ARM )
+#endif  // !( ENABLE_SIMD_OPT && ( defined( TARGET_SIMD_X86 ) || defined( TARGET_SIMD_ARM ) ) )
 }
 
 ///< creates compile info string containing OS, Compiler and Bit-depth (e.g. 32 or 64 bit).
From 2b81c8d6019e588eca9e1d3980bc8abe1d826e74 Mon Sep 17 00:00:00 2001
From: Gabriel Hege <gabriel.hege@hhi.fraunhofer.de>
Date: Tue, 1 Apr 2025 18:04:31 +0200
Subject: [PATCH] fix error: SSE vector return without SSE enabled changes the
 ABI [-Werror=psabi]

---
 source/Lib/CommonLib/x86/FixMissingIntrin.h | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/source/Lib/CommonLib/x86/FixMissingIntrin.h b/source/Lib/CommonLib/x86/FixMissingIntrin.h
index 6ef103748..d5e235847 100644
--- a/source/Lib/CommonLib/x86/FixMissingIntrin.h
+++ b/source/Lib/CommonLib/x86/FixMissingIntrin.h
@@ -56,6 +56,7 @@ POSSIBILITY OF SUCH DAMAGE.
 
 namespace vvenc
 {
+#if defined( USE_SSE41 ) || defined( USE_SSE42 ) ||  defined( USE_AVX ) || defined( USE_AVX2 )
 
 #ifdef MISSING_INTRIN_mm_storeu_si16
 static inline void _mm_storeu_si16( void* p, __m128i a )
@@ -133,6 +134,8 @@ static inline int64_t _mm_extract_epi64( __m128i a, int i )
 }
 #endif
 
+#endif // defined( USE_SSE41 ) || defined( USE_SSE42 ) ||  defined( USE_AVX ) || defined( USE_AVX2 )
+
 #if defined( USE_AVX ) || defined( USE_AVX2 )
 
 // this should only be true for non-x86 architectures
